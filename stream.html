<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="author" content="" />
	<meta name="description" content="" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<title>Fn tests</title>

	<!-- Bolt requires this. -->
	<script>
		document.documentElement.className = 'js';
		window.DEBUG = true;
	</script>

	<link rel="icon" type="image/png" href="images/favicon.png" />
	<link rel="apple-touch-icon" href="/apple-touch-icon.png" />

	<link rel="stylesheet" href="http://stephen.band/bolt/css/normalise.css" />
	<link rel="stylesheet" href="http://stephen.band/bolt/css/dom.css" />
	<link rel="stylesheet" href="http://stephen.band/bolt/css/text.css" />
	<link rel="stylesheet" href="http://stephen.band/bolt/css/table.css" />
	<link rel="stylesheet" href="http://stephen.band/bolt/css/block.css" />
	<link rel="stylesheet" href="http://stephen.band/bolt/css/grid.css" />
	<link rel="stylesheet" href="http://stephen.band/bolt/css/utilities.css" />
</head>
<body>

<table>
	<thead>
		<tr><th class="span-1/3"><code>Stream</code></th></tr>
	</thead>
	<tbody>
		<tr><td><code>.of(arg1, arg2, ...)</code></td>  <td>Create a push()-able, shift()-able stream - a <i>buffer</i> stream - with initial values.</td></tr>
		<tr><td><code>.from(array)</code></td>          <td>Create a buffer stream from an array of values.</td></tr>
		<tr><td><code>.throttle(time)</code></td>       <td>Create a throttled stream.</td></tr>
		<tr><td><code>.clock(time)</code></td>          <td>Create a regularly timed stream.</td></tr>
	</tbody>
</table>

<table>
	<thead>
		<tr><th class="span-1/3"><code>Stream()</code></th></tr>
	</thead>
	<tbody>
		<tr>
			<td class="span-1/3"><code>new Stream(fn)</code></td>
			<td><code>fn</code> â€“ function that takes parameters <code>(notify, stop)</code> and returns an object with a <code>.shift()</code> method, and optionally <code>.push()</code> and <code>.stop()</code>.</td></tr>
		</tr>

		<tr><th class="span-1/3">Transform</th></tr>

		<tr><td class="span-1/3"><code>.filter(fn)</code></td>           <td>Filters the stream</td></tr>
		<tr><td class="span-1/3"><code>.map(fn)</code></td>              <td>Map the stream.</td></tr>
		<tr><td class="span-1/3"><code>.reduce(fn, seed)</code></td>     <td>Reduce the stream.</td></tr>
		<tr><td class="span-1/3"><code>.fold(fn, seed)</code></td>       <td>Fold the stream.</td></tr>

		<tr><td class="span-1/3"><code>.ap(object)</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.chain(fn)</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.chunk(n)</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.clone()</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.concat(list)</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.dedup()</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.first()</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.join()</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.latest()</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.partition(fn)</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.take(i)</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.rest(i)</code></td>           <td></td></tr>
		<tr><td class="span-1/3"><code>.unique()</code></td>           <td></td></tr>

		<tr><th class="span-1/3">Read and write</th></tr>

		<tr><td class="span-1/3"><code>.shift()</code></td>              <td><p>Consume a value from the stream.</p><p>All other consumer methods delegate to <code>.shift()</code>. Indeed, a stream is composed of series of <code>.shift()</code> functions, each transforming the result of calling <code>.shift()</code> on the previous.</p></td></tr>
		<tr><td class="span-1/3"><code>.each(fn)</code></td>             <td>Consume the stream greedily, calling <code>fn</code> with values when they become available.</td></tr>
		<tr><td class="span-1/3"><code>.next()</code></td>               <td><p>Consume a value from the stream and return it in the form <code>{ value: value, done: true | false }</code>. This makes a stream also an iterator.</p></td></tr>
		<tr><td class="span-1/3"><code>.pipe(stream)</code></td>         <td>Pipe values into another stream.</td></tr>
		<tr><td class="span-1/3"><code>.push(value)</code></td>          <td>If the stream is pushable, pushes <code>value</code> into the top of the stream (otherwise does nothing).</td></tr>

		<tr><td class="span-1/3"><code>.toArray()</code></td>            <td>Consume all values into a new array.</td></tr>
		<tr><td class="span-1/3"><code>.toJSON()</code></td>             <td>Alias of <code>.toArray()</code></td></tr>

		<tr><td class="span-1/3"><code>.stop()</code></td>               <td>Stop the stream from generating any new values.</td></tr>
		<tr><td class="span-1/3"><code>.then(fn)</code></td>             <td>Call <code>fn</code> when the stream has completed.</td>
		<!--tr><td class="span-1/3"><code>.toString()</code></td>           <td>Returns a string of all values.</td></tr-->
	</tbody>
</table>



	<script src="polyfills/number.isnan.js"></script>
	<script src="polyfills/object.assign.js"></script>

	<script src="js/fn.js"></script>
	<script src="js/observe.js"></script>
	<script src="js/observable-noproxy.js"></script>
	<script src="js/stream.js"></script>
	<script src="js/stream.observe.js"></script>
	<script src="js/pool.js"></script>

	<!--script src="js/store.js"></script-->
	<!--script src="js/router.js"></script-->

	<script src="test/test.js"></script>

	<!--script src="test/fn.utils.test.js"></script>
	<script src="test/fn.test.js"></script>
	<script src="test/stream.test.js"></script>
	<script src="test/stream.stop.test.js"></script>
	<script src="test/stream.clone.test.js"></script>
	<script src="test/stream.observe.test.js"></script-->
	<script src="test/observable-test.js"></script>
	<!--script src="test/test.stream.property.js"></script-->
	<!--script src="test/test.store.js"></script>
	<script src="test/router.test.js"></script-->

	<script>
		var in1 = document.getElementById('1');
		var in2 = document.getElementById('2');
		var in3 = document.getElementById('3');

		var st1 = Stream.Events('input', in1).map(Fn.getPath('target.value')).buffer(in1.value).map(parseFloat);
		var st2 = Stream.Events('input', in2).map(Fn.getPath('target.value')).buffer(in2.value).map(parseFloat);
		var st3 = Stream.Combine(Fn.add, st1, st2);

		st3.each(Fn.set('value', in3));
	</script>
</body>
</html>
